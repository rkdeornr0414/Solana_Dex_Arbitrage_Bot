"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRepositionLiquidityMethod = getRepositionLiquidityMethod;
exports.repositionLiquidityV2Ix = repositionLiquidityV2Ix;
const web3_js_1 = require("@solana/web3.js");
const __1 = require("../..");
const remaining_accounts_util_1 = require("../../utils/remaining-accounts-util");
function getRepositionLiquidityMethod(params) {
    if ("newLiquidityAmount" in params) {
        return {
            byLiquidity: {
                newLiquidityAmount: params.newLiquidityAmount,
                existingRangeTokenMinA: params.existingRangeTokenMinA,
                existingRangeTokenMinB: params.existingRangeTokenMinB,
                newRangeTokenMaxA: params.newRangeTokenMaxA,
                newRangeTokenMaxB: params.newRangeTokenMaxB,
            },
        };
    }
    else {
        throw new Error("Unsupported method variant for params: " + JSON.stringify(params));
    }
}
function repositionLiquidityV2Ix(program, params) {
    const { newTickLowerIndex, newTickUpperIndex, tokenTransferHookDepositAccountsA, tokenTransferHookDepositAccountsB, tokenTransferHookWithdrawalAccountsA, tokenTransferHookWithdrawalAccountsB, whirlpool, tokenProgramA, tokenProgramB, positionAuthority, funder, position, positionTokenAccount, tokenMintA, tokenMintB, tokenOwnerAccountA, tokenOwnerAccountB, tokenVaultA, tokenVaultB, existingTickArrayLower, existingTickArrayUpper, newTickArrayLower, newTickArrayUpper, memoProgram, systemProgram, ...remainingParams } = params;
    const [remainingAccountsInfo, remainingAccounts] = new remaining_accounts_util_1.RemainingAccountsBuilder()
        .addSlice(remaining_accounts_util_1.RemainingAccountsType.TransferHookDepositA, tokenTransferHookDepositAccountsA)
        .addSlice(remaining_accounts_util_1.RemainingAccountsType.TransferHookDepositB, tokenTransferHookDepositAccountsB)
        .addSlice(remaining_accounts_util_1.RemainingAccountsType.TransferHookWithdrawalA, tokenTransferHookWithdrawalAccountsA)
        .addSlice(remaining_accounts_util_1.RemainingAccountsType.TransferHookWithdrawalB, tokenTransferHookWithdrawalAccountsB)
        .build();
    const ix = program.instruction.repositionLiquidityV2(newTickLowerIndex, newTickUpperIndex, getRepositionLiquidityMethod(remainingParams), remainingAccountsInfo, {
        accounts: {
            whirlpool,
            tokenProgramA,
            tokenProgramB,
            memoProgram: memoProgram ?? __1.MEMO_PROGRAM_ADDRESS,
            positionAuthority,
            funder,
            position,
            positionTokenAccount,
            tokenMintA,
            tokenMintB,
            tokenOwnerAccountA,
            tokenOwnerAccountB,
            tokenVaultA,
            tokenVaultB,
            existingTickArrayLower,
            existingTickArrayUpper,
            newTickArrayLower,
            newTickArrayUpper,
            systemProgram: systemProgram ?? web3_js_1.SystemProgram.programId,
        },
        remainingAccounts,
    });
    return {
        instructions: [ix],
        cleanupInstructions: [],
        signers: [],
    };
}
//# sourceMappingURL=reposition-liquidity-ix.js.map